---
title: 程序语言设计(上)
date: 2022-12-18 18:29:37
permalink: /pages/beda9a/
categories: 
  - 软件设计师
tags: 
  - 软件设计师
---



## 程序设计语言（上）

### 1.程序设计语言及其构成

#### 1.1 程序语言发展阶段

计算机要通过程序或指令来控制才能完成各种任务。 程序设计语言（计算机语言）：人与机器交换信息的语言。

阶段：

1. 机器语言（低级语言）：**二进制**指令代码，直观性差，容易出错，计算机直接执行
2. 汇编语言（低级语言）：用**简单的符号**代替部分指令，推广移植困难，需经汇编程序转化后执行
3. 高级语言：更符号人的思维，易读易记，便于推广，有**解释**和**编译**两种执行方式



#### 1.2 高级程序设计语言划分

从客观系统描述划分：

- 面向过程语言：
  - 命令式语言：FORTRAN、ALGOL、COBOL、C和Pascal等
  - 结构化语言（也属于命令式）：C、Pascal 等
  - 函数式语言： Lisp 等
  - 逻辑式编程语言：Prolog 等
- 面向对象语言：`PHP、Delphi、Java、C++、Smalltalk、Python、C# 等`

------

从程序执行角度划分：

- 编译类程序设计语言：`C、C++、Delphi、Java`
- 解释类程序设计语言：`Python、PHP、Ruby、JavaScript`
- 脚本语言：`通常为解释执行。JavaScript为客户端脚本语言，Python、Ruby、PHP 为服务器端脚本语言`



#### 1.3 常见的高级程序设计语言

- Fortran语言：**第一个高级程序设计语言**，用于并行计算、科学计算和高性能计算。
- Lisp语言：**函数式程序语言**，符号处理，人工智能
- Prolog ：逻辑式语言，建造专家系统、自然语言理解、智能知识库等
- SQL：**结构化查询语言**，特殊目的的编程语言，用于查询、更新和管理关系数据库



通用的程序设计语言：C、C#、C++、Java、PHP、Python、JavaScript 等。

- `C语言`：通用、结构化程序设计语言，简洁丰富可移植，能访问操作系统和底层硬件。
- `C#语言`：面向对象，运行于 .NET Framework
- `C++语言`：C语言基础上增加了类机制，面向对象，高效
- `Java语言`：面向对象，跨平台，通用的程序设计语言
- `Php`：服务端执行、嵌入HTML文档的脚本语言，制作动态网页
- `Python`：面向对象，解释型程序设计语言，通用的脚本语言
- `JavaScript 语言`：为网页添加动态功能



#### 1.4 标记语言

非编程语言，不包含任何逻辑或算法

常见有：

- HTML ： HyperText Markup Language，超文本标记语言
- XML ： Extensible Markup Language，可扩展标记语言
- XHTML ：Extensible HyperText Markup Language，扩展的超文本标记语言



#### 1.5 程序设计语言及其构成

数据成分： 常量、变量、全局量、局部量以及数据类型。

运算成分：程序语言允许使用运算符号及运算规则。

控制成分：[顺序结构](https://so.csdn.net/so/search?q=顺序结构&spm=1001.2101.3001.7020)、选择结构、循环结构。

![img](https://pic1.xuehuaimg.com/proxy/raw.githubusercontent.com/Kryust/image/main/img/56712be2c2054009ad5bd0d70ea88b2a.png)



### 2.表达式

表达式的分类有如下：

- 前缀表达式 +ab
- 中缀表达式 a+b
- 后缀表达式（**逆波兰式**） ab+

```bash
示例： 

将中缀表达式(a-b)*(c+5)转为后缀表达式
首先注意计算的顺序 a-b 、c+5、最后是 *
得到结果 ab- c5+ *
```

后缀表达式的运算过程（转为中缀表达式）

使用栈可以很方便的进行运算，运算过程如下：

1. 遇到运算对象压入到栈里面
2. 遇到运算符从栈中取出两个对象，并进行计算
3. 将计算的结果再压入到栈里面
4. 重复上述过程，直到结束

```bash
上面的例子 (a-b)*(c+5)，转为后缀表达式 ab- c5+ *

将a、b入栈
遇到运算符*-* ⇒ 进行 a-b 运算 ⇒ 计算结果x压入栈
将 c、5如入栈
遇到 + ⇒ 进行 c-5 运算 ⇒ 将计算结果 y 压入栈
遇到 * ⇒ 进行 x*y 运算 ⇒ 将计算结果 压入栈
```

> 金典练习：

```bash
算术表达式采用后缀式表示时不需要使用括号，使用（）就可以方便地进行求值。a－b*（c＋d）的后缀式为（）。

A. 队列 
B. 数组 
C.栈 
D. 广义表

A. a b c d- * +
B. a b c d * + -
C. a b – c * d +
D. a b c d + * -

答案 C 、D
```



### 3.传值和传址调用

▶数据类型：

数据值是否改变：

- 常量：只有右值，值不能改变
- 变量：有左值和右值，值可改变

作用域：

- 全局变量：存储空间一般不变
- 局部变量：存储空间动态变化

数据类型：

- 基本类型： int、char、float、double、bool
- 特殊类型：void
- 用于定义类型：enum
- 构造类型：数组、结构、联合
- 指针类型：type *
- 抽象数据类型：类类型

| 传递方式         | 主要特点                                                     |
| :--------------- | :----------------------------------------------------------- |
| 传值调用         | 形参取的是实参的值，形参的改变不会导致调用点所传的实参的值发生改变 |
| 引用（传址）调用 | 形参取的是实参的地址，即相当于实参存储的是地址引用，因此其值的改变同时改变了实参的值。 参数的左值为地址，右值为具体的值。 |



`1.传值调用示例`：

```c
void swap( int x, int y) {
    int t;
    t=x;x=y;y=t;
    printf("%d %d", x, y);
}
 
main() {
    int a=3,b=4;
    swap(a,b);
    printf("%d %d", a, b);
}


// 刚刚开始调用的时候 a=3, b=4, x=3, y=4
// 执行完之后，a=3, b=4, x=4, y=3
```

`2.传址调用示例`：

```c
void swap( int *x, int *y) {
    int a, *t = &a;
    *t=*x;*x=*y;*y=*t;
    printf("%d %d", *x, *y);
}
 
main() {
    int a=3,b=4;
    swap(&a, &b);
    printf("%d %d", a, b);
}

// 刚刚开始调用的时候 a=3, b=4, x=3, y=4
// 执行完之后，a=4, 3=4, x=4, y=3
```



### 4.语言处理程序

- 语言处理程序：`将高级语言转换成计算机可执行的机器语言，分为汇编、编译和解释程序`
- 汇编程序：翻译由汇编语言编写的程序
- 解释程序：针对高级编写的源程序，直接解释执行源程序
- 编译程序：源程序翻译成目标语言程序，然后执行目标程序

![img](https://pic1.xuehuaimg.com/proxy/raw.githubusercontent.com/Kryust/image/main/img/d3ed72c0ce064f418549105b602dfab8.png)

▶汇编程序

`把汇编语言书写的程序翻译成与之等价的机器语言程序的翻译程序。`

汇编程序输入的是用汇编语言书写的源程序，输出的是用机器语言表示的目标程序。

汇编语言是为特定计算机或计算机系列设计的一种面向机器的语言，由汇编执行指令和汇编伪指令组成。

- **第一次扫描：**定义符号的值并创建符号表 ST。汇编器中，利用了LC（地址跟踪计数器）。LC是汇编语言的指针，每识别出1个指令，LC就增加1。
- **第二次扫描**：生成机器语言，产生目标程序。第一次扫描已经生成了符号表，第二次扫描时即可利用汇编器的“指令表”将对应的指令翻译成机器指令，同时将LC执行的内存地址填入机器码或数值。



▶解释程序

解释程序是一种语言处理程序。

在词法、语法和语义分析方面与编译程序的工作原理基本相同。

但在运行用户程序时，它直接执行源程序或源程序的内部形式（中间代码）。

**解释程序并不产生目标程序，这是它和编译程序的主要区别。**



▶高级语言执行过程

用高级语言编写出的程序要能在计算机上运行时，由于计算机识别二进制，因此需要对源程序依次进行**预处理、编译和链接**的过程，才能确保源程序正确被执行。

![img](https://pic1.xuehuaimg.com/proxy/raw.githubusercontent.com/Kryust/image/main/img/c82d61ab319349c885ec8bf38c20b99a.png)



### 5.编译程序

▶编译过程

编译程序的功能是把某高级语言书写的源程序翻译成与之等价的目标程序（汇编语言程序或机器语言程序）。编译程序的工作可分为6个阶段，如下图所示，实际的编辑可能会将其中的某些阶段结合在一起进行处理。

![img](https://pic1.xuehuaimg.com/proxy/raw.githubusercontent.com/Kryust/image/main/img/c77790fd2c9e44cea73d4b777b3e6983.png)



> 注意：`在编译阶段，语义检查属于静态语义检查。动态语义检查是在运行阶段进行的。`

![img](https://pic1.xuehuaimg.com/proxy/raw.githubusercontent.com/Kryust/image/main/img/8ed3d012f3e842e4ae92551b528ea198.png)



▶词法分析

词法分析：从左到右逐个扫码源程序中的字符，识别其中的关键字`（或保留字）、标识符、常数、运算符、分隔符（标点符号和括号）`等



▶语法分析

语法分析：根据语法规则将单词符号分解成各类语法单位，并分析源程序是否存在语法上的错误。包括：`语言结构错误、if...end不匹配、缺少分号、括号不匹配、表达式缺少操作数等`。



▶语义分析

语义分析：进行类型分析和检查，主要检测程序是否存在静态语义错误。包括：`运算符和运算类型不符合`，如`取余时用浮点数。`



▶出错处理

静态错误：

- 编译时所发现的程序错误（编译正确的程序没有静态错误）
- 分为语法错误和静态语义错误。
- 语法错误包括：单词拼写错误、标点符号错误、表达式中缺少操作数、括号不匹配等有关语言结构上的错误。
- 静态语义错误：运算符和运算类型不符合等错误。

动态错误：

- 发生在程序运行时（程序可通过编译）
- 也叫动态语义错误
- 包括：陷入死循环、变量取零时做除数、引用数组下标越界等错误。



### 6.有限自动机和正规式

#### 6.1 正规式

正规式：`由正规文法转换而来，通常正规文法等价于正规式。`

| 文法产生式 | 正规式    |        |
| :--------- | :-------- | ------ |
| 规则1      | A→xB, B→y | A=xy   |
| 规则2      | A→xA\|y   | A=x*y  |
| 规则3      | A→x, A→y  | A=x\|y |

> `*`表示可以出现0次或任意多次
>
> `x|y`表示可能x、也可能是y

| 正规式      | 正规集                       |
| :---------- | :--------------------------- |
| `ab`        | 符号串ab构成的集合           |
| `a|b`       | 字符串a、b构成的集合         |
| `a*`        | 由0个或多个a构成的符号串集合 |
| `(a|b)*`    | 所有字符a和b构成的串的集合   |
| `a(a|b)*`   | a为首字符的a、b字符串集合    |
| `(a|b)*abb` | 以abb结尾的a、b字符串的集合  |

> ab：只有一种情况，就是 ab
>
> a|b：有两种情况，a或者b
>
> a*：有无数种情况



#### 6.2 正规式与有限自动机的状态转换

正规式与有限自动机的状态转换图的关系

![img](https://pic1.xuehuaimg.com/proxy/raw.githubusercontent.com/Kryust/image/main/img/aae6817c67a546daafb73cfb9b259ec9.png)



#### 6.3 有限自动机

有限自动机是在词法分析阶段使用的，它分为确定的有限自动机（DFA）和非确定的有限自动机（NDFA）

> 任何一个有穷的序列，经过有穷步转移后，都能落到一个具体的状态上，有穷自动机能够判断是接受还是拒绝。

```bash
DFA的定义

DFA定义，M = ( S, ∑, f, q₀, Z )，其中

S：有穷状态集

∑：输入字母表；

f ：S × ∑ → S 转移函数，表示一个状态的后续状态有若干个

(S × ∑* → S 转移函数，扩展转移函数)

q₀ ∈ S ：初始状态

Z ⊆ S ：接受状态（终结状态）集合

L(M) = { w ∈ ∑* | f(q₀,w) ∈ Z }
```



#### 6.4 非确定的有限自动机(NFA)

确定的有限自动机，它所有的状态的下一个状态是唯一确定的。

非确定的有限自动机的下一个状态是可以不唯一确定

- **ε移动**：不需要任何输入符号，就可以从一个状态转到另一个状态。例如下图的 `q2` 可以不输入符号直接转成 `q3`
- **多种选择**（含0种选择）：比如下图的中 `q1`状态下，输入1时可以转成`q2`，也可以原地不动（2种选择）；`q3`状态下输入0，无路可走，没有选择（0种选择）。

![img](https://pic1.xuehuaimg.com/proxy/raw.githubusercontent.com/Kryust/image/main/img/2b2c6dc9a53a4c0581aae9d355ad0368.png)



> 原文出自： 
>
> https://blog.csdn.net/chenjian723122704/article/details/124516183
