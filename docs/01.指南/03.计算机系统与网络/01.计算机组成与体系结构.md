---
title: 计算机组成与体系结构
date: 2022-08-30 21:47:09
permalink: /pages/0ca117/
categories: 
  - 软件设计师
tags: 
  - 软件设计师
---


# 计算机组成与体系结构

## 1.计算机基础知识

### 1.1 数据的表示

- 进制转换
- 码制
- 浮点数的表示
- 逻辑数运算 



#### 1.1.1 进制转换

 一般为一些基础的进制转换，[二进制](https://so.csdn.net/so/search?q=二进制&spm=1001.2101.3001.7020)(B)，八进制（O），十进制（D），十六进制（H）这里是后缀表示法

易混淆的为（计算机常见的数据计量单位）：

1. 比特(bit/位)： 最小的单位
2. 字节(bytes/Byte)： 比位大一些，1字节=8位(bit)即1B=8b
3. KB：1KB=1024B
4. MB：1MB=1024KB
5. GB：1GB=1024MB



常用的进制缩写

| 进制     | 简写 |
| -------- | ---- |
| 十进制   | D    |
| 二进制   | B    |
| 八进制   | Q    |
| 十六进制 | H    |



#### 1.1.2 码制

`原码`：符号位+数值位绝对值。

`反码`：正数的反码是原码本身，负数的反码是符号位不变数值位按位取反。

`补码`：正数的补码是原码本身，负数的补码是符号位不变数值位在反码基础上加1。

`移码`：正数和负数的移码都是在补码基础上符号位取反。



原码无法直接在计算机中进行运算，即原码的负值与原码相加和实际情况不一致。		
![image-20220823001155187](https://pic1.xuehuaimg.com/proxy/raw.githubusercontent.com/isicman/image/main/img/image-20220823001155187.png)



数值的表示范围

- 原码： -127至127
- 反码： -127至127
- 补码： -128至127

补码比原码和反码的取值范围要大1个，因为在原码和反码中0需要有正0和负0两个，而在补码和移码中0不存在正负0；

![img](https://pic1.xuehuaimg.com/proxy/raw.githubusercontent.com/isicman/image/main/img/51b7488cb7654320b7e94e41112b53ff.png)



#### 1.1.3 浮点数的表示

浮点数的表示格式：

| 阶符 | 阶码 | 数符 | 尾数 |
| ---- | ---- | ---- | ---- |

要点注意：

- 浮点数各部分表示意义：`N = 尾数*基数的指数次幂`
- 一般尾数用补码，阶码用移码；
- 阶码的位数决定数的表示范围，位数越多范围越大；
- 尾数的位数决定数的有效精度，位数越多精度越高。
- 浮点数运算规则：`对阶>尾数计算>结果格式化`
- 对阶时，小数向大数看齐；
- 对阶是通过较小数的尾数右移实现的。



浮点数表示：

![image-20220823002902139](https://pic1.xuehuaimg.com/proxy/raw.githubusercontent.com/isicman/image/main/img/image-20220823002902139.png)

其中*M*为尾数，*e*为指数，*R*为基数。
当计算机在进行浮点数运算时，需要经过 **`对阶 → 尾数计算 → 结果格式化`** 三个步骤
例：

![image-20220823002924595](https://pic1.xuehuaimg.com/proxy/raw.githubusercontent.com/isicman/image/main/img/image-20220823002924595.png)

在这两个浮点数进行运算时，把阶数小的往高的对(小阶对大阶)，即`0.119 * 10 ^ 3`，然后进行同阶的尾数计算，最后格式化成d.dddd的结果。



#### 1.1.4 逻辑数运算

 1、**运算符**

- 较高优先级（关系运算符）：`<（小于）<=（小于或等于） >（大于）>=（大于或等于）`。

- 较低优先级（关系运算符）：`==等于 !=不等于。逻辑运算符`。

- 逻辑或`（ ||、+  、∪、∨、OR）`：连接的两个逻辑值全 0 时才取 0。

- 逻辑与`（&&、*、・、∩、∧、AND  ）`：连接的两个逻辑值全 1 时才取 1。
- 逻辑异或`（⊕、XOR  ）`：连接的两个逻辑值不相同时才取 1，相同则取 0。
- 逻辑非`（！、﹃ 、～ 、NOT，—）`：将原逻辑值取反即可。



2、**优先级**

`！（非）->&&（与）->||（或）`

逻辑运算符中的`“&&”`和 `“||”`低于关系运算符，`“!”`高于算术运算符

因此运算符的优先顺序为：`！>`算术运算符`>`关系运算符`> && > || >`赋值运算符



3、**短路原则**

在逻辑表达式的求解中，并不是所有的逻辑运算符都要被执行。

（1）`a && b && c` 只有 a 为真时，才需要判断 b 的值，只有 a 和 b 都为真时，才需要判断 c 的值。

（2）`a || b || c` 只要a 为真，就不必判断b和c的值，只有 a 为假，才判断 b,a 和b 都为假才判断c。




### 1.2 校验码

- 奇偶校验(Parity Codes)
- 循环校验码CRC(Cyclic Redundancy Check,CRC)
- 海明校验
- 校验码对比



#### 1.2.1 奇偶校验(Parity Codes)

 是一种简单有效的校验方法。它可以检测代码中奇数位出错的编码，但不能发现偶数位出错的情况，即当合法编码中的奇数位发生了错误时，即编码中的1变成0或0变成1，则该编码中1的个数的奇偶性就发生了变化，从而可以发现错误。`因而奇偶校验码只有检错的功能，不能进行纠错。`



#### 1.2.2  循环校验码CRC

广泛应用于数据通信领域和磁介质存储系统校验码是由信息码产生的，校验码位数越多，该代码的校验能力就越强。在求CRC编码时，采用的是模2运算。模2加减运算的规则是按位运算，不发生借位和进位。`也是只能检错，不能进行纠错。`



#### 1.2.3 海明校验码

是一种利用奇偶性来检错和纠错的校验方法。海明码的构成方法是在数据位之间的特定位置上插入 k 个校验位，通过扩大码距来实现检错和纠错。

设数据位是n位，校验位是k位海明校验码校验位计算：

![image-20220823003952015](https://pic1.xuehuaimg.com/proxy/raw.githubusercontent.com/isicman/image/main/img/image-20220823003952015.png)



#### 1.2.4 校验码对比

![image-20220823004116872](https://pic1.xuehuaimg.com/proxy/raw.githubusercontent.com/isicman/image/main/img/image-20220823004116872.png)





## 2.计算机的组成

### 2.1 CPU结构

主机分为CPU和主存储器（又称内存储器、内存）

![主机结构](https://pic1.xuehuaimg.com/proxy/raw.githubusercontent.com/isicman/image/main/img/6dffbfdeb65a4ceb8d74ee08ca66a18a.png)



> 运算器部件：

1. **算数逻辑单元ALU** ：是能实现多组算术运算和逻辑运算的组合逻辑电路。
2. **累加寄存器AC** ： 是一个通用寄存器，虽然叫累加器，但还支持减法、读出、移位、循环移位、求补等操作。它为ALU提供一个工作区，暂时存放**ALU**运算的结果信息。
3. **数据缓冲寄存器DR**，在**内存储器**（内存）进行读写操作时，将数据放入其。
4. **状态条件寄存器PSW**，存储在运算过程中的标志位（进位、溢出、为零、为负、终端、方向、单步等）



> 控制部件：

1.控制器部件：

1. **地址寄存器AR** ：用来保存当前CPU所访问的内存单元的地址信息。
2. **程序计数器PC** ：存放指令地址，将指令由内存取到指令寄存器中，且程序计数器更新为下一指令的地址

2.指令部件：

1. **指令寄存器IR** :用于暂存当前正在执行的指令
2. **指令译码器ID** :译码呗。

3.时序部件：为指令的执行产生时序信号。

![在这里插入图片描述](https://pic1.xuehuaimg.com/proxy/raw.githubusercontent.com/isicman/image/main/img/f8fe44b7f20a4cb7a83f39fa7da9b6d1.png)



### 2.2 计算机体系结构分类

1. 单指令流单数据流SISD：单控制部分，单处理器，单主存模块；常见于单片机
2. 单指令流多数据流SIMD：单控制部分，多处理器，多主存模块；阵列处理器，各处理以异步执行同一条指令，像GPU做矩阵处理时那样。
3. 多指令流单数据流MISD：多控制部分，单处理器，多主存模块；没得这种东西。
4. 多指令流多数据流MIMD：多控制部分，多处理器，多主存模块；家用计算机



### 2.3 指令系统

复杂指令集计算机CISC，Complex 复杂的。上世纪用的东西，定制的、占地面积巨大的计算机。
精简指令集计算机RISC，Reduced 减少，缩小。
在CISC指令集的各种指令中，大约有20%的指令会被反复使用，占整个程序代码的80%。而余下的80%的指令却不经常使用，在程序设计中只占20%。

![image-20220823005331554](https://pic1.xuehuaimg.com/proxy/raw.githubusercontent.com/isicman/image/main/img/image-20220823005331554.png)



### 2.4 CPU架构

CPU的分类：

- x86架构
- ARM架构
- MIPS架构

**x86架构**，因Intel的处理器型号早期以数字86结尾，因此其架构被称为x86架构，常用与家用计算机中。其早期是16位的，后来AMD与1999年抢先推出了64位元、x86架构的处理器，命名为AMD 64。Intel于2001年紧随其后推出IA-64，是和惠普合作的英特尔安腾处理器，是一种和x86完全不同的架构。后来统称为x86-64或x64。那么x86架构是用的是前文说到的复杂指令集（CISC），windows8以前的操作系统都是仅支持x86架构的。在较为新的微架构中，x86处理器会把x86指令更换为更像RISC那样的微指令再进行执行，提升性能。

**ARM架构**，英文是AdvancedRISC Machine进阶精简指令集机器。
起初叫AcornRISC Machine，Acorn是公司名字。显而易见是用的RISC复杂指令集，是32位元的处理器。因其节能低耗的特点，常用与嵌入式系统与移动通讯领域（手机芯片）。

**MIPS架构**，英文是Microprocessorwithout Interlocked Pipeline Stages，无内部互锁流水级微处理器，也是采用RISC的处理器架构。机制是尽量利用软件办法避免流水线中的数据相关问题，强调硬件协同提高性能，同时简化硬件设计。是64位元处理器，支持除法指令。



### 2.5 流水线

流水线是指在程序执行时，多条指令**重叠进行操作**的一种准**并行**处理技术，提高各部件的利用率和指令单平均执行速率。

#### 2.5.1 流水线的周期和执行时间

![流水线还子那个示意](https://pic1.xuehuaimg.com/proxy/raw.githubusercontent.com/isicman/image/main/img/8932ac4de2d04b0785dcfe4ceaad1325.png)



- **流水线周期**：是流水线步骤中**最长**的一段时间。是执行多条指令时，一条指令的开始到下一条指令的最晚开始时间的总称。私以为可以看图中间的一竖列。
- **流水线执行时间计算公式**：**1条指令执行时间 + 剩下的指令数 \* 流水线周期**



🌰：若指令流水线把一条指令分为取指、分析和执行三部分，且三部分的时间分别是2ns、2ns、1ns，流水线的周期是：**2ns** 。



理论上：

- 1条指令的执行时间是：2ns + 2ns + 1ns = **5ns**
- 100令的执行时间是：5ns + 99 * 2ns = **203ns**

`但是！执行时间比周期要小，这就很麻烦，不如统一一下。`

实际上：

- 1条指令的执行时间是：2ns + 2ns + 2ns = **6ns**
- 100令的执行时间是：6ns + 99 * 2ns = **204ns**

但是！两种都算对。



#### 2.5.2 流水线吞吐率

**流水线吞吐率**：是指在单位时间内流水线所完成的任务数量或输出结果的数量。
**流水线吞吐率计算公式**： **指令条数 / 流水线执行时间**
**流水线最大吞吐率计算公式**： **1条 / 流水线周期**，是一个理想状态
流水线的吞吐率为： **100条 / 203ns**
流水线的最大吞吐率为： **1条 / 2ns**



#### 2.5.3 流水线加速比

**流水线加速比公式**： **不使用流水线的执行时间 / 使用流水线的执行时间**
不使用流水线时间：( 2ns + 2ns + 1ns ) * 100条 = **500ns**
使用流水线时间： **203ns**
流水线加速比：2.463054



#### 2.5.4 流水线的效率

**流水线效率**：是指流水线设备的利用率。在时空图上，流水线的效率定义为那个任务占用的时空区与k个流水段总的时空区之比。

![例子s](https://pic1.xuehuaimg.com/proxy/raw.githubusercontent.com/isicman/image/main/img/a282ed002e8646cba9466301881159c9.png)

**率公式**： `任务占用的时空区（灰的） / 总的时空区（白的）`
已上图为例即 （1+1+1+3）* 4 / 15 * 4 = 0.4



### 2.6 缓存

**缓存（cache）**：缓存是指可以进行高速数据交换的存储器，它先于内存与CPU交换数据，因此速率很快。CPU一般有多层缓存，在计算机存储系统体系中，缓存是访问速度最快的层次。

如果以h代表对Cache的访问命中率，t1表示Cache的周期时间，t2表示主存储器周期时间，以读操作为例，使用“Cache+主存储器”的系统的平均周期为t3，则

![image-20220823010334563](https://pic1.xuehuaimg.com/proxy/raw.githubusercontent.com/isicman/image/main/img/image-20220823010334563.png)

其中（1-h）称为失效率或未命中率

![层次化储存结构](https://pic1.xuehuaimg.com/proxy/raw.githubusercontent.com/isicman/image/main/img/865f65558fdf4f128d11bbd228bad16a.png)

首先，CPU去Cache中取数据，如果Cache里面有则称为命中，没有称为未命中，去内存（主存）中去取。





### 2.7 局部性原理

在CPU访问寄存器时，无论是存取**数据**或**指令**，都趋于聚集在一片连续的区域中，这就被称为局部性原理。

**时间局部性**：（循环中）被引用过一次的储存器位置未来会被多次引用

**空间局部性**：如果一个储存器的位置被引用，那么将来他附近的位置也不会被引用。

**工作集理论**：程序运行时被频繁访问的页面集合



### 2.8 主存储器

| 主存储器类别          | 简写                                                         |
| --------------------- | ------------------------------------------------------------ |
| 随机存取存储器（RAM） | DRAM动态、SRAM静态                                           |
| 只读存储器（ROM）     | MROM掩模式、PROM一次可编程、EPROM可擦除、Flash Memory闪存储器（闪存） |

🌰：内存地址从AC000H到C7FFFH，共有`112K`个地址单元，如果该内存地址按字（16bit）编址，由28片存储芯片构成。已知构成此内存的芯片每片有16K个存储单元，则该芯片每个存储单元存储`4bit`。



### 2.9 磁盘

![磁盘结构](https://pic1.xuehuaimg.com/proxy/raw.githubusercontent.com/isicman/image/main/img/e2bbc67662a247559f1faa7cce26f6db.png)

左侧是多叠的磁盘

`存取时间 = 寻道时间 + 等待时间（平均定位时间 + 转动延迟）`

`寻道时间`是指`磁头`移动到磁道所需的时间；

`等待时间`为等待读写的`扇区`转到磁头下方所用的实践

🌰：假设某磁盘的每个磁道划分成11个物理块，每块存放1个逻辑记录。逻辑记录R0…R10存放到同一个磁道上，记录的存放顺序如下表所示。

| 物理块   | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 逻辑记录 | R0   | R1   | R2   | R3   | R4   | R5   | R6   | R7   | R8   | R9   | R10  |

如果磁盘的旋转周期为33ms，磁头当前处在R0的开始处。若系统是用的**单缓冲区**顺序处理这些记录，每个记录处理时间为3ms。

> Ps:单缓存区意味着只能存放一块逻辑记录，如果没处理完，磁盘可是会接着旋转的。

![常规](https://pic1.xuehuaimg.com/proxy/raw.githubusercontent.com/isicman/image/main/img/24607bc43bd543488edc4b85e79a2438.png)

读取 + 处理R0，定位到R1所消耗时间为：`3ms + 33ms = 36ms`
那处理到R9，且定位到R10所消耗的时间为：`10 * 36ms = 360ms`
读取 + 处理R10所消耗的实践为：`3ms + 3ms = 6ms`
则处理这11个记录的最长（常规）时间为：`360ms + 6ms = 366ms`

![在这里插入图片描述](https://pic1.xuehuaimg.com/proxy/raw.githubusercontent.com/isicman/image/main/img/70b747668d1b4518920bd79af6e1c181.png)

理想态是读取且处理完R0后，磁盘正好转动到R1那里。
即对信息存储进行优化分布后，处理11个记录的最少时间为：66ms

> 即：`[ 3ms（读取）+ 3ms （处理）] * 11 = 66ms`



### 2.10 总线

根据总线所处位置不同，总线通常分为三种：内部总线、系统总线、外部总线。

- 内部总线：计算机内部各个芯片与处理器之间的总线，类似于CPU与南北桥的线路连接，是芯片级别。
- 系统总线：计算机主板和各个拆线版之间的总线，类似PCIE线，VGA接口线等，是插线板级别，常说的总线就是系统总线。
- 外部总线：计算机和外设、计算机之间的总线，又称通信总线。

总线分为数据总线、地址总线和控制总线



### 2.11 串联系统与并联系统

**串联系统**是组成系统的所有单元中任一单元失效就会导致整个系统失效的系统。
可靠度R:

![image-20220824233814380](https://pic1.xuehuaimg.com/proxy/raw.githubusercontent.com/isicman/image/main/img/image-20220824233814380.png)

失效率λ:

![image-20220824233826632](https://pic1.xuehuaimg.com/proxy/raw.githubusercontent.com/isicman/image/main/img/image-20220824233826632.png)

**并联系统**只有当所有子系统失效时，系统才会失效。
可靠度R:

![image-20220824233838354](https://pic1.xuehuaimg.com/proxy/raw.githubusercontent.com/isicman/image/main/img/image-20220824233838354.png)

失效率λ:

![image-20220824233848606](https://pic1.xuehuaimg.com/proxy/raw.githubusercontent.com/isicman/image/main/img/image-20220824233848606.png)



### 2.12 校验码

**海明码校验码/汉明码Hamming Code**

1. 注意：海明码的校验位在`2的次方位`上，例如`1，2，4，8，16位`
2. 定义：海明码是一个有多个校验位，拥有检错纠错能力的编码。
3. 基本思想：将有效信息按照某种规律分为若干组，每组安排一个校验位进行就行测试，后产生多位检测信息，并从中得到具体出错位置，将其取反来纠正。
4. 步骤：`计算校验位数` → `确定校验码位置` → `确定校验码` → `计算`



🌰：求1011的海明码。

1.计算校验位数

假设用 **N** 表示添加了校验码后整个编码信息的二进制位数长度，用 **I** 代表其中有效信息位， **r** 表示添加的校验码位，他们之间的关系应满足：

![image-20220824234052311](https://pic1.xuehuaimg.com/proxy/raw.githubusercontent.com/isicman/image/main/img/image-20220824234052311.png)

即 **4+ r ≤ 2r - 1**



2.确定校验码位置

求得校验码位至少为3位，分别放在第20，21，22位。即第**1**位，第**2**位和第**4**位。

| 位数   | 7       | 6       | 5       | 4    | 3       | 2    | 1    |
| ------ | ------- | ------- | ------- | ---- | ------- | ---- | ---- |
| 信息位 | 1（I4） | 0（I3） | 1（I2） |      | 1（I1） |      |      |
| 校验位 |         |         |         | r2   |         | r1   | r0   |



3.确定校验码

【I4】 7 = 0111 第2,1,0位；即第7位的信息为会影响到 r2 r1 r0
【I3】6 = 0110 第2,1位； 即第6位的信息为会影响到 r2 r1
【I2】5 = 0101 第3,1位；即第5位的信息为会影响到 r2 r0
【I1】3 = 0011 第2,1位；即第3位的信息为会影响到 r1 r0



4.计算

r2 = I4 ⊕ I3 ⊕ I2 = 1 ⊕ 0 ⊕ 1 = 0
r1 = I4 ⊕ I3 ⊕ I1 = 1 ⊕ 0 ⊕ 1 = 0
r0 = I4 ⊕ I2 ⊕ I1 = 1 ⊕ 1 ⊕ 1 = 1



故1011的海明码为`1010101`

> ps:异或运算，同为0，异为1

| a    | b    | a ⊕ b |
| ---- | ---- | ----- |
| 0    | 0    | 0     |
| 0    | 1    | 1     |
| 1    | 0    | 1     |
| 1    | 1    | 0     |

🌰：纠正海明码1011101的错误。

计算得到的校验码为 100 ，给出的校验码为101，按位异或 得到 001，即第一位错误，将其取反即可，即1011100。